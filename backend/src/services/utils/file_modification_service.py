"""
File Modification Service using LangChain tools
Applies code modifications generated by LLM to the repository
"""

import os
import json
import logging
from typing import Dict, Any, List, Optional
from pathlib import Path

from langchain_community.agent_toolkits.file_management.toolkit import FileManagementToolkit
from langchain_community.tools.file_management import (
    ReadFileTool,
    WriteFileTool,
    ListDirectoryTool,
    CopyFileTool,
    DeleteFileTool,
    MoveFileTool,
)

logger = logging.getLogger(__name__)


class FileModificationService:
    """
    Service to apply code modifications to files using LangChain tools.
    
    Parses LLM-generated code changes (JSON format) and applies them
    to the repository using LangChain's file management tools.
    """
    
    def __init__(self, working_directory: str):
        """
        Initialize file modification service.
        
        Args:
            working_directory: Root directory for file operations (repository path)
        """
        self.working_directory = Path(working_directory)
        
        # Initialize LangChain file tools
        self.toolkit = FileManagementToolkit(
            root_dir=str(self.working_directory),
            selected_tools=["read_file", "write_file", "list_directory", "copy_file"]
        )
        
        self.tools = {
            "read": ReadFileTool(root_dir=str(self.working_directory)),
            "write": WriteFileTool(root_dir=str(self.working_directory)),
            "list": ListDirectoryTool(root_dir=str(self.working_directory)),
            "copy": CopyFileTool(root_dir=str(self.working_directory)),
        }
        
        logger.info(f"FileModificationService initialized for {self.working_directory}")
    
    def apply_modifications(self, llm_response: str) -> Dict[str, Any]:
        """
        Parse LLM response and apply file modifications.
        
        Expected JSON format from LLM:
        {
          "files": [
            {
              "path": "relative/path/to/file.py",
              "action": "create|modify|delete",
              "content": "complete file content",
              "explanation": "what this file does"
            }
          ],
          "summary": "Overall summary of changes"
        }
        
        Args:
            llm_response: JSON string from LLM with file modifications
            
        Returns:
            Dict with results of modifications
        """
        try:
            # Parse JSON response
            modifications = self._parse_llm_response(llm_response)
            
            if not modifications:
                logger.warning("No modifications parsed from LLM response")
                return {
                    "success": False,
                    "error": "No valid modifications found in LLM response",
                    "files_modified": []
                }
            
            # Apply each modification
            results = []
            for file_mod in modifications.get("files", []):
                result = self._apply_single_modification(file_mod)
                results.append(result)
            
            # Summary
            success_count = sum(1 for r in results if r["success"])
            failed_count = len(results) - success_count
            
            return {
                "success": failed_count == 0,
                "files_modified": results,
                "total": len(results),
                "succeeded": success_count,
                "failed": failed_count,
                "summary": modifications.get("summary", "")
            }
            
        except Exception as e:
            logger.error(f"Error applying modifications: {e}", exc_info=True)
            return {
                "success": False,
                "error": str(e),
                "files_modified": []
            }
    
    def _parse_llm_response(self, llm_response: str) -> Optional[Dict[str, Any]]:
        """
        Parse LLM response to extract file modifications.
        
        Handles both pure JSON and markdown code blocks.
        
        Args:
            llm_response: Raw LLM response
            
        Returns:
            Parsed modifications dict or None
        """
        try:
            # Try direct JSON parsing
            return json.loads(llm_response)
        except json.JSONDecodeError:
            # Try to extract JSON from markdown code block
            if "```json" in llm_response:
                start = llm_response.find("```json") + 7
                end = llm_response.find("```", start)
                json_str = llm_response[start:end].strip()
                return json.loads(json_str)
            elif "```" in llm_response:
                start = llm_response.find("```") + 3
                end = llm_response.find("```", start)
                json_str = llm_response[start:end].strip()
                return json.loads(json_str)
            else:
                logger.error("Could not parse JSON from LLM response")
                return None
    
    def _apply_single_modification(self, file_mod: Dict[str, Any]) -> Dict[str, Any]:
        """
        Apply a single file modification.
        
        Args:
            file_mod: File modification dict with path, action, content
            
        Returns:
            Result dict with success status and details
        """
        path = file_mod.get("path")
        action = file_mod.get("action", "modify")
        content = file_mod.get("content", "")
        explanation = file_mod.get("explanation", "")
        
        if not path:
            return {
                "success": False,
                "path": None,
                "action": action,
                "error": "No path specified"
            }
        
        try:
            # Ensure path is relative and safe
            safe_path = self._sanitize_path(path)
            
            if action == "create":
                return self._create_file(safe_path, content, explanation)
            elif action == "modify":
                return self._modify_file(safe_path, content, explanation)
            elif action == "delete":
                return self._delete_file(safe_path, explanation)
            else:
                return {
                    "success": False,
                    "path": path,
                    "action": action,
                    "error": f"Unknown action: {action}"
                }
                
        except Exception as e:
            logger.error(f"Error applying modification to {path}: {e}")
            return {
                "success": False,
                "path": path,
                "action": action,
                "error": str(e)
            }
    
    def _sanitize_path(self, path: str) -> str:
        """
        Sanitize file path to prevent directory traversal attacks.
        
        Args:
            path: Input file path
            
        Returns:
            Sanitized relative path
        """
        # Remove leading slashes
        path = path.lstrip("/")
        
        # Resolve to absolute path and check it's within working directory
        abs_path = (self.working_directory / path).resolve()
        
        if not str(abs_path).startswith(str(self.working_directory.resolve())):
            raise ValueError(f"Path {path} is outside working directory")
        
        # Return relative path
        return str(abs_path.relative_to(self.working_directory))
    
    def _create_file(self, path: str, content: str, explanation: str) -> Dict[str, Any]:
        """
        Create a new file using LangChain WriteFileTool.
        
        Args:
            path: Relative file path
            content: File content
            explanation: Explanation of what the file does
            
        Returns:
            Result dict
        """
        logger.info(f"Creating file: {path}")
        
        # Create parent directories if needed
        abs_path = self.working_directory / path
        abs_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Use LangChain WriteFileTool
        result = self.tools["write"].run({
            "file_path": path,
            "text": content,
            "append": False
        })
        
        logger.info(f"Created file: {path}")
        
        return {
            "success": True,
            "path": path,
            "action": "create",
            "explanation": explanation,
            "result": result
        }
    
    def _modify_file(self, path: str, content: str, explanation: str) -> Dict[str, Any]:
        """
        Modify an existing file using LangChain WriteFileTool.
        
        Args:
            path: Relative file path
            content: New file content
            explanation: Explanation of changes
            
        Returns:
            Result dict
        """
        logger.info(f"Modifying file: {path}")
        
        abs_path = self.working_directory / path
        
        # Create backup if file exists
        if abs_path.exists():
            backup_path = str(abs_path) + ".backup"
            self.tools["copy"].run({
                "source_path": path,
                "destination_path": path + ".backup"
            })
            logger.info(f"Created backup: {backup_path}")
        
        # Write new content
        result = self.tools["write"].run({
            "file_path": path,
            "text": content,
            "append": False
        })
        
        logger.info(f"Modified file: {path}")
        
        return {
            "success": True,
            "path": path,
            "action": "modify",
            "explanation": explanation,
            "backup": path + ".backup" if abs_path.exists() else None,
            "result": result
        }
    
    def _delete_file(self, path: str, explanation: str) -> Dict[str, Any]:
        """
        Delete a file.
        
        Args:
            path: Relative file path
            explanation: Explanation of why file is deleted
            
        Returns:
            Result dict
        """
        logger.info(f"Deleting file: {path}")
        
        abs_path = self.working_directory / path
        
        if abs_path.exists():
            abs_path.unlink()
            logger.info(f"Deleted file: {path}")
            
            return {
                "success": True,
                "path": path,
                "action": "delete",
                "explanation": explanation
            }
        else:
            return {
                "success": False,
                "path": path,
                "action": "delete",
                "error": "File does not exist"
            }
    
    def read_file(self, path: str) -> str:
        """
        Read a file using LangChain ReadFileTool.
        
        Args:
            path: Relative file path
            
        Returns:
            File content
        """
        return self.tools["read"].run({"file_path": path})
    
    def list_directory(self, path: str = ".") -> List[str]:
        """
        List files in a directory using LangChain ListDirectoryTool.
        
        Args:
            path: Relative directory path
            
        Returns:
            List of file/directory names
        """
        result = self.tools["list"].run({"dir_path": path})
        # Parse the string result into a list
        return result.strip().split("\n") if result else []
    
    def get_modified_files_summary(self, results: Dict[str, Any]) -> str:
        """
        Generate a human-readable summary of modifications.
        
        Args:
            results: Results from apply_modifications()
            
        Returns:
            Summary string
        """
        if not results.get("success"):
            return f"‚ùå Modifications failed: {results.get('error', 'Unknown error')}"
        
        summary_lines = [
            f"‚úÖ Successfully modified {results['succeeded']} file(s)",
            ""
        ]
        
        for file_result in results.get("files_modified", []):
            if file_result["success"]:
                action_icon = {
                    "create": "‚ûï",
                    "modify": "‚úèÔ∏è",
                    "delete": "üóëÔ∏è"
                }.get(file_result["action"], "üìù")
                
                summary_lines.append(
                    f"{action_icon} {file_result['action'].upper()}: {file_result['path']}"
                )
                if file_result.get("explanation"):
                    summary_lines.append(f"   ‚Üí {file_result['explanation']}")
        
        if results.get("failed", 0) > 0:
            summary_lines.append("")
            summary_lines.append(f"‚ö†Ô∏è  {results['failed']} modification(s) failed")
        
        return "\n".join(summary_lines)
